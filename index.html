<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI助手</title>
    <style>
        /* ==================== 核心修复 CSS：确保页面不滚动 ==================== */
        html, body {
            height: 100%;           /* 占据整个视口高度 */
            margin: 0;
            padding: 0;
            overflow: hidden;       /* **关键：禁用整个页面的滚动** */
            font-family: Arial, sans-serif;
            background-color: #f5f5f5;
        }

        /* 调整布局，让 chat-container 垂直居中并占据屏幕大部分空间 */
        body {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .chat-container {
            width: 100%;
            max-width: 800px;
            /* 使用固定高度，或者根据视口高度计算，这里使用 Vh */
            height: 90vh; 
            
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            box-sizing: border-box; 
        }
        
        /* =========== 聊天框滚动修复后的关键样式 =========== */
        .messages {
            /* 设定一个相对固定的高度，通过计算或 Vh 确保有足够的空间 */
            /* 假设聊天容器高 90vh，标题+输入区域约 200px，这里设置一个大值 */
            height: 60vh; 
            
            /* 核心滚动设置：确保内容溢出时显示滚动条 */
            overflow-y: scroll; 
            
            border: 1px solid #ddd;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 5px;
            background: #fff;
        }
        /* ================================================= */
        
        .message {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            white-space: pre-wrap;
            word-break: break-word;
            max-width: 85%;
        }
        .user-message {
            background: #e3f2fd;
            text-align: right;
            margin-left: auto;
        }
        .ai-message {
            background: #f5f5f5;
            text-align: left;
            margin-right: auto;
        }
        .input-area {
            display: flex;
            gap: 10px;
            margin-bottom: 8px;
            align-items: flex-end; 
        }

        textarea {
            flex: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            resize: none; 
            min-height: 40px; 
            overflow-y: hidden; 
            line-height: 1.5; 
        }

        button {
            padding: 10px 16px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            height: 40px; 
            box-sizing: border-box; 
            line-height: 20px; 
        }
        button:active { transform: translateY(1px); }
        .bottom-actions {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .finish-btn {
            background: #4CAF50;
        }
        .copy-btn {
            background: #FF9800;
        }
        #copyNotice {
            display: none;
            color: green;
            margin-left: 8px;
        }
        .loading {
            color: #666;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="chat-container">
        <h2>AI助手</h2>
        <p>请与AI助手对话，完成后请点击“复制全部对话”，并将内容粘贴到问卷页面。</p>
        
        <div class="messages" id="messages" aria-live="polite">
            <div class="message ai-message" id="initial-ai">
您好，我是您的AI助手。为了能最高效地协助您，请在提出需求时，尽可能清晰地告诉我以下信息：
【角色】 - 您希望我扮演谁？
【背景】 - 相关的背景情况是什么？
【任务】 - 您需要我具体完成什么？
【要求】 - 需要达到什么标准或注意什么？
【输出】 - 您希望最终的成果是什么格式？
请开始告诉我您的需求吧！
            </div>
        </div>
        
        <div class="input-area">
            <textarea id="userInput" placeholder="请输入您的问题..." rows="1" aria-label="输入您的问题"></textarea>
            <button onclick="sendMessage()">发送</button>
        </div>

        <div class="bottom-actions">
            <button class="copy-btn" onclick="copyChat()">复制全部对话</button>
            <button class="finish-btn" onclick="finishChat()">结束对话并返回问卷</button>
            <span id="copyNotice">✅ 已复制！请返回问卷并粘贴在指定文本框中。</span>
        </div>
    </div>

    <script>
        // JS 代码逻辑保持不变，但新增了滚轮事件处理
        let conversationHistory = [
            {
                role: 'system',
                content: '你是一个专业的助手，要友好、支持性地回应用户，提供有帮助的支持。每次回复尽量简洁，在200字以内。'
            }
        ];

        const userInput = document.getElementById('userInput');
        const messagesDiv = document.getElementById('messages');
        const initialAiText = document.getElementById('initial-ai').textContent.trim();

        conversationHistory.push({ role: 'assistant', content: initialAiText });
        const pid = new URLSearchParams(window.location.search).get('pid') || 'unknown';
        let hasCopied = false;

        function autoResize() {
            userInput.style.height = 'auto'; 
            const newHeight = Math.min(userInput.scrollHeight, 200); 
            userInput.style.height = newHeight + 'px';
        }

        userInput.addEventListener('input', autoResize); 
        userInput.addEventListener('keypress', function(event) {
            if (event.key === 'Enter' && !event.shiftKey) { 
                event.preventDefault(); 
                sendMessage();
            }
        });
        window.addEventListener('load', autoResize); 
        
        // =========================================================
        // 关键修复：添加滚轮事件监听器，阻止页面滚动
        // =========================================================
        messagesDiv.addEventListener('wheel', function(e) {
            // 检查内容是否可以滚动
            const maxScroll = messagesDiv.scrollHeight - messagesDiv.clientHeight;
            
            // 如果滚轮事件发生在聊天框内，并且聊天框内容已达到顶部或底部限制
            if (maxScroll <= 0 || (e.deltaY < 0 && messagesDiv.scrollTop === 0) || (e.deltaY > 0 && messagesDiv.scrollTop >= maxScroll)) {
                // 如果不能继续滚动（已到顶或底），则阻止事件向上冒泡，防止页面滚动
                e.preventDefault();
            }
            // 否则，允许默认的滚动事件在 messagesDiv 内部执行
        });


        async function sendMessage() {
            const message = userInput.value.trim();
            if (!message) return;

            addMessage(message, 'user');
            conversationHistory.push({ role: 'user', content: message });
            userInput.value = '';
            autoResize(); 

            const loadingId = addMessage('AI正在思考中...', 'ai', true);

            try {
                // ======= 注意：请将下面的 API KEY 替换为你的真实 API KEY =======
                const response = await fetch('https://api.deepseek.com/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + 'sk-8c93bd024f66443f8159d0831583dccc'
                    },
                    body: JSON.stringify({
                        model: 'deepseek-chat',
                        messages: conversationHistory,
                        stream: false,
                        max_tokens: 500
                    })
                });

                if (!response.ok) {
                    throw new Error('网络请求失败: ' + response.status);
                }

                const data = await response.json();
                removeMessage(loadingId);

                if (data.choices && data.choices[0] && data.choices[0].message) {
                    const aiResponse = data.choices[0].message.content;
                    addMessage(aiResponse, 'ai');
                    conversationHistory.push({ role: 'assistant', content: aiResponse });
                } else {
                    const errorMsg = '抱歉，我暂时无法回复，请稍后再试。';
                    addMessage(errorMsg, 'ai');
                    conversationHistory.push({ role: 'assistant', content: errorMsg });
                }
            } catch (error) {
                removeMessage(loadingId);
                const errorMsg = '网络连接出现问题，请检查网络后重试。';
                addMessage(errorMsg, 'ai');
                conversationHistory.push({ role: 'assistant', content: errorMsg });
                console.error('sendMessage error:', error);
            }
        }
        window.sendMessage = sendMessage;


        function addMessage(content, type, isTemp = false) {
            const messageDiv = document.createElement('div');
            const messageId = isTemp ? 'temp-' + Date.now() : null;

            messageDiv.className = `message ${type}-message`;
            messageDiv.textContent = content;
            if (messageId) messageDiv.id = messageId;

            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
            return messageId;
        }

        function removeMessage(id) {
            const element = document.getElementById(id);
            if (element) element.remove();
        }


        function copyChat() {
            const header = `被试编号: ${pid}\n复制时间: ${new Date().toLocaleString()}\n\n`;
            const body = conversationHistory
                .filter(m => m.role !== 'system')
                .map(m => (m.role === 'user' ? '用户: ' : 'AI: ') + m.content)
                .join('\n\n');

            const fullText = header + body;

            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(fullText).then(() => {
                    hasCopied = true;
                    showCopyNotice();
                }).catch(err => {
                    console.warn('navigator.clipboard 写入失败，使用 fallback:', err);
                    fallbackCopyText(fullText);
                });
            } else {
                fallbackCopyText(fullText);
            }
        }
        window.copyChat = copyChat;


        function fallbackCopyText(text) {
            try {
                const tempTextarea = document.createElement('textarea');
                tempTextarea.value = text;
                tempTextarea.style.position = 'fixed';
                tempTextarea.style.left = '-9999px';
                document.body.appendChild(tempTextarea);
                tempTextarea.focus();
                tempTextarea.select();

                const successful = document.execCommand('copy');
                document.body.removeChild(tempTextarea);
                if (successful) {
                    hasCopied = true;
                    showCopyNotice();
                } else {
                    alert('复制失败，请手动选中对话并复制。');
                }
            } catch (err) {
                console.error('fallbackCopyText error:', err);
                alert('复制失败，请手动选中对话并复制。');
            }
        }

        function showCopyNotice() {
            const notice = document.getElementById('copyNotice');
            notice.style.display = 'inline';
            notice.style.opacity = '1';
        }

        function finishChat() {
            if (!hasCopied) {
                alert('请先点击复制对话再退出此页面');
                return;
            }

            const endTime = new Date().toISOString();
            console.log('对话结束时间:', endTime);

            alert('对话已结束，正在返回问卷页面。');
            if (document.referrer && document.referrer.includes('您的问卷域名')) {
                window.location.href = document.referrer;
            } else {
                window.close();
            }
        }
        window.finishChat = finishChat;

        window.addEventListener('beforeunload', function (e) {
            if (!hasCopied) {
                const confirmationMessage = '您尚未复制对话内容。请先点击“复制全部对话”并粘贴到问卷后再离开。';
                (e || window.event).returnValue = confirmationMessage; 
                return confirmationMessage; 
            }
            return undefined;
        });
    </script>
</body>
</html>
